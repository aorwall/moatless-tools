{
  "instance_id": "pydata__xarray-4684",
  "model_patch": "diff --git a/xarray/coding/times.py b/xarray/coding/times.py\nindex 59f8b897..3e1aa02c 100644\n--- a/xarray/coding/times.py\n+++ b/xarray/coding/times.py\n@@ -156,8 +156,8 @@ def _decode_datetime_with_pandas(flat_num_dates, units, calendar):\n     # cause an OutOfBoundsDatetime (Overflow) error\n     with warnings.catch_warnings():\n         warnings.filterwarnings(\"ignore\", \"invalid value encountered\", RuntimeWarning)\n-        pd.to_timedelta(flat_num_dates.min(), delta) + ref_date\n-        pd.to_timedelta(flat_num_dates.max(), delta) + ref_date\n+        pd.to_timedelta(flat_num_dates.min(), unit=delta) + ref_date\n+        pd.to_timedelta(flat_num_dates.max(), unit=delta) + ref_date\n \n     # Cast input dates to integers of nanoseconds because `pd.to_datetime`\n     # works much faster when dealing with integers\n@@ -413,9 +413,8 @@ def encode_cf_datetime(dates, units=None, calendar=None):\n         if ref_date.tz is not None:\n             ref_date = ref_date.tz_convert(None)\n \n-        # Wrap the dates in a DatetimeIndex to do the subtraction to ensure\n-        # an OverflowError is raised if the ref_date is too far away from\n-        # dates to be encoded (GH 2272).\n+        # Here we do not cast to int, to ensure we keep the full precision\n+        # for milliseconds\n         num = (pd.DatetimeIndex(dates.ravel()) - ref_date) / time_delta\n         num = num.values.reshape(dates.shape)\n \n@@ -423,9 +422,45 @@ def encode_cf_datetime(dates, units=None, calendar=None):\n         num = _encode_datetime_with_cftime(dates, units, calendar)\n \n     num = cast_to_int_if_safe(num)\n+    print(\"Encoded datetime data:\", num)\n     return (num, units, calendar)\n \n \n+def _cleanup_netcdf_time_units(units):\n+    delta, ref_date = _unpack_netcdf_time_units(units)\n+    try:\n+        units = \"{} since {}\".format(delta, format_timestamp(ref_date))\n+    except OutOfBoundsDatetime:\n+        # don't worry about reifying the units if they're out of bounds\n+        pass\n+    return units\n+\n+\n+def _encode_datetime_with_cftime(dates, units, calendar):\n+    \"\"\"Fallback method for encoding dates using cftime.\n+\n+    This method is more flexible than xarray's parsing using datetime64[ns]\n+    arrays but also slower because it loops over each element.\n+    \"\"\"\n+    import cftime\n+\n+    if np.issubdtype(dates.dtype, np.datetime64):\n+        # numpy's broken datetime conversion only works for us precision\n+        dates = dates.astype(\"M8[us]\").astype(datetime)\n+\n+    def encode_datetime(d):\n+        return np.nan if d is None else cftime.date2num(d, units, calendar)\n+\n+    return np.vectorize(encode_datetime)(dates)\n+\n+\n+def cast_to_int_if_safe(num):\n+    int_num = np.array(num, dtype=np.int64)\n+    if (num == int_num).all():\n+        num = int_num\n+    return num\n+\n+\n def encode_cf_timedelta(timedeltas, units=None):\n     if units is None:\n         units = infer_timedelta_units(timedeltas)\n",
  "model_name_or_path": "Devin",
  "pass_or_fail": "fail",
  "model_patch_files": [
    "xarray/coding/times.py"
  ],
  "repo": "pydata/xarray",
  "base_commit": "0f1eb96c924bad60ea87edd9139325adabfefa33",
  "patch": "diff --git a/xarray/coding/times.py b/xarray/coding/times.py\n--- a/xarray/coding/times.py\n+++ b/xarray/coding/times.py\n@@ -26,6 +26,7 @@\n _STANDARD_CALENDARS = {\"standard\", \"gregorian\", \"proleptic_gregorian\"}\n \n _NS_PER_TIME_DELTA = {\n+    \"ns\": 1,\n     \"us\": int(1e3),\n     \"ms\": int(1e6),\n     \"s\": int(1e9),\n@@ -35,7 +36,15 @@\n }\n \n TIME_UNITS = frozenset(\n-    [\"days\", \"hours\", \"minutes\", \"seconds\", \"milliseconds\", \"microseconds\"]\n+    [\n+        \"days\",\n+        \"hours\",\n+        \"minutes\",\n+        \"seconds\",\n+        \"milliseconds\",\n+        \"microseconds\",\n+        \"nanoseconds\",\n+    ]\n )\n \n \n@@ -44,6 +53,7 @@ def _netcdf_to_numpy_timeunit(units):\n     if not units.endswith(\"s\"):\n         units = \"%ss\" % units\n     return {\n+        \"nanoseconds\": \"ns\",\n         \"microseconds\": \"us\",\n         \"milliseconds\": \"ms\",\n         \"seconds\": \"s\",\n@@ -151,21 +161,22 @@ def _decode_datetime_with_pandas(flat_num_dates, units, calendar):\n         # strings, in which case we fall back to using cftime\n         raise OutOfBoundsDatetime\n \n-    # fixes: https://github.com/pydata/pandas/issues/14068\n-    # these lines check if the the lowest or the highest value in dates\n-    # cause an OutOfBoundsDatetime (Overflow) error\n-    with warnings.catch_warnings():\n-        warnings.filterwarnings(\"ignore\", \"invalid value encountered\", RuntimeWarning)\n-        pd.to_timedelta(flat_num_dates.min(), delta) + ref_date\n-        pd.to_timedelta(flat_num_dates.max(), delta) + ref_date\n-\n-    # Cast input dates to integers of nanoseconds because `pd.to_datetime`\n-    # works much faster when dealing with integers\n-    # make _NS_PER_TIME_DELTA an array to ensure type upcasting\n-    flat_num_dates_ns_int = (\n-        flat_num_dates.astype(np.float64) * _NS_PER_TIME_DELTA[delta]\n-    ).astype(np.int64)\n+    # To avoid integer overflow when converting to nanosecond units for integer\n+    # dtypes smaller than np.int64 cast all integer-dtype arrays to np.int64\n+    # (GH 2002).\n+    if flat_num_dates.dtype.kind == \"i\":\n+        flat_num_dates = flat_num_dates.astype(np.int64)\n \n+    # Cast input ordinals to integers of nanoseconds because pd.to_timedelta\n+    # works much faster when dealing with integers (GH 1399).\n+    flat_num_dates_ns_int = (flat_num_dates * _NS_PER_TIME_DELTA[delta]).astype(\n+        np.int64\n+    )\n+\n+    # Use pd.to_timedelta to safely cast integer values to timedeltas,\n+    # and add those to a Timestamp to safely produce a DatetimeIndex.  This\n+    # ensures that we do not encounter integer overflow at any point in the\n+    # process without raising OutOfBoundsDatetime.\n     return (pd.to_timedelta(flat_num_dates_ns_int, \"ns\") + ref_date).values\n \n \n@@ -252,11 +263,24 @@ def decode_cf_timedelta(num_timedeltas, units):\n \n \n def _infer_time_units_from_diff(unique_timedeltas):\n-    for time_unit in [\"days\", \"hours\", \"minutes\", \"seconds\"]:\n+    # Note that the modulus operator was only implemented for np.timedelta64\n+    # arrays as of NumPy version 1.16.0.  Once our minimum version of NumPy\n+    # supported is greater than or equal to this we will no longer need to cast\n+    # unique_timedeltas to a TimedeltaIndex.  In the meantime, however, the\n+    # modulus operator works for TimedeltaIndex objects.\n+    unique_deltas_as_index = pd.TimedeltaIndex(unique_timedeltas)\n+    for time_unit in [\n+        \"days\",\n+        \"hours\",\n+        \"minutes\",\n+        \"seconds\",\n+        \"milliseconds\",\n+        \"microseconds\",\n+        \"nanoseconds\",\n+    ]:\n         delta_ns = _NS_PER_TIME_DELTA[_netcdf_to_numpy_timeunit(time_unit)]\n         unit_delta = np.timedelta64(delta_ns, \"ns\")\n-        diffs = unique_timedeltas / unit_delta\n-        if np.all(diffs == diffs.astype(int)):\n+        if np.all(unique_deltas_as_index % unit_delta == np.timedelta64(0, \"ns\")):\n             return time_unit\n     return \"seconds\"\n \n@@ -416,7 +440,15 @@ def encode_cf_datetime(dates, units=None, calendar=None):\n         # Wrap the dates in a DatetimeIndex to do the subtraction to ensure\n         # an OverflowError is raised if the ref_date is too far away from\n         # dates to be encoded (GH 2272).\n-        num = (pd.DatetimeIndex(dates.ravel()) - ref_date) / time_delta\n+        dates_as_index = pd.DatetimeIndex(dates.ravel())\n+        time_deltas = dates_as_index - ref_date\n+\n+        # Use floor division if time_delta evenly divides all differences\n+        # to preserve integer dtype if possible (GH 4045).\n+        if np.all(time_deltas % time_delta == np.timedelta64(0, \"ns\")):\n+            num = time_deltas // time_delta\n+        else:\n+            num = time_deltas / time_delta\n         num = num.values.reshape(dates.shape)\n \n     except (OutOfBoundsDatetime, OverflowError):\n",
  "test_patch": "diff --git a/xarray/tests/test_coding_times.py b/xarray/tests/test_coding_times.py\n--- a/xarray/tests/test_coding_times.py\n+++ b/xarray/tests/test_coding_times.py\n@@ -6,7 +6,7 @@\n import pytest\n from pandas.errors import OutOfBoundsDatetime\n \n-from xarray import DataArray, Dataset, Variable, coding, decode_cf\n+from xarray import DataArray, Dataset, Variable, coding, conventions, decode_cf\n from xarray.coding.times import (\n     cftime_to_nptime,\n     decode_cf_datetime,\n@@ -479,27 +479,36 @@ def test_decoded_cf_datetime_array_2d():\n     assert_array_equal(np.asarray(result), expected)\n \n \n+FREQUENCIES_TO_ENCODING_UNITS = {\n+    \"N\": \"nanoseconds\",\n+    \"U\": \"microseconds\",\n+    \"L\": \"milliseconds\",\n+    \"S\": \"seconds\",\n+    \"T\": \"minutes\",\n+    \"H\": \"hours\",\n+    \"D\": \"days\",\n+}\n+\n+\n+@pytest.mark.parametrize((\"freq\", \"units\"), FREQUENCIES_TO_ENCODING_UNITS.items())\n+def test_infer_datetime_units(freq, units):\n+    dates = pd.date_range(\"2000\", periods=2, freq=freq)\n+    expected = f\"{units} since 2000-01-01 00:00:00\"\n+    assert expected == coding.times.infer_datetime_units(dates)\n+\n+\n @pytest.mark.parametrize(\n     [\"dates\", \"expected\"],\n     [\n-        (pd.date_range(\"1900-01-01\", periods=5), \"days since 1900-01-01 00:00:00\"),\n-        (\n-            pd.date_range(\"1900-01-01 12:00:00\", freq=\"H\", periods=2),\n-            \"hours since 1900-01-01 12:00:00\",\n-        ),\n         (\n             pd.to_datetime([\"1900-01-01\", \"1900-01-02\", \"NaT\"]),\n             \"days since 1900-01-01 00:00:00\",\n         ),\n-        (\n-            pd.to_datetime([\"1900-01-01\", \"1900-01-02T00:00:00.005\"]),\n-            \"seconds since 1900-01-01 00:00:00\",\n-        ),\n         (pd.to_datetime([\"NaT\", \"1900-01-01\"]), \"days since 1900-01-01 00:00:00\"),\n         (pd.to_datetime([\"NaT\"]), \"days since 1970-01-01 00:00:00\"),\n     ],\n )\n-def test_infer_datetime_units(dates, expected):\n+def test_infer_datetime_units_with_NaT(dates, expected):\n     assert expected == coding.times.infer_datetime_units(dates)\n \n \n@@ -535,6 +544,7 @@ def test_infer_cftime_datetime_units(calendar, date_args, expected):\n         (\"1h\", \"hours\", np.int64(1)),\n         (\"1ms\", \"milliseconds\", np.int64(1)),\n         (\"1us\", \"microseconds\", np.int64(1)),\n+        (\"1ns\", \"nanoseconds\", np.int64(1)),\n         ([\"NaT\", \"0s\", \"1s\"], None, [np.nan, 0, 1]),\n         ([\"30m\", \"60m\"], \"hours\", [0.5, 1.0]),\n         (\"NaT\", \"days\", np.nan),\n@@ -958,3 +968,30 @@ def test_decode_ambiguous_time_warns(calendar):\n         assert not record\n \n     np.testing.assert_array_equal(result, expected)\n+\n+\n+@pytest.mark.parametrize(\"encoding_units\", FREQUENCIES_TO_ENCODING_UNITS.values())\n+@pytest.mark.parametrize(\"freq\", FREQUENCIES_TO_ENCODING_UNITS.keys())\n+def test_encode_cf_datetime_defaults_to_correct_dtype(encoding_units, freq):\n+    times = pd.date_range(\"2000\", periods=3, freq=freq)\n+    units = f\"{encoding_units} since 2000-01-01\"\n+    encoded, _, _ = coding.times.encode_cf_datetime(times, units)\n+\n+    numpy_timeunit = coding.times._netcdf_to_numpy_timeunit(encoding_units)\n+    encoding_units_as_timedelta = np.timedelta64(1, numpy_timeunit)\n+    if pd.to_timedelta(1, freq) >= encoding_units_as_timedelta:\n+        assert encoded.dtype == np.int64\n+    else:\n+        assert encoded.dtype == np.float64\n+\n+\n+@pytest.mark.parametrize(\"freq\", FREQUENCIES_TO_ENCODING_UNITS.keys())\n+def test_encode_decode_roundtrip(freq):\n+    # See GH 4045. Prior to GH 4684 this test would fail for frequencies of\n+    # \"S\", \"L\", \"U\", and \"N\".\n+    initial_time = pd.date_range(\"1678-01-01\", periods=1)\n+    times = initial_time.append(pd.date_range(\"1968\", periods=2, freq=freq))\n+    variable = Variable([\"time\"], times)\n+    encoded = conventions.encode_cf_variable(variable)\n+    decoded = conventions.decode_cf_variable(\"time\", encoded)\n+    assert_equal(variable, decoded)\n",
  "problem_statement": "Millisecond precision is lost on datetime64 during IO roundtrip\n<!-- A short summary of the issue, if appropriate -->\r\nI have millisecond-resolution time data as a coordinate on a DataArray. That data loses precision when round-tripping through disk.\r\n\r\n#### MCVE Code Sample\r\n<!-- In order for the maintainers to efficiently understand and prioritize issues, we ask you post a \"Minimal, Complete and Verifiable Example\" (MCVE): http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports -->\r\n\r\n[bug_data.p.zip](https://github.com/pydata/xarray/files/4595145/bug_data.p.zip)\r\n\r\nUnzip the data. It will result in a pickle file.\r\n\r\n```python\r\nbug_data_path = '/path/to/unzipped/bug_data.p'\r\ntmp_path = '~/Desktop/test.nc'\r\n\r\nwith open(bug_data_path, 'rb') as f:\r\n    data = pickle.load(f)\r\n\r\nselector = dict(animal=0, timepoint=0, wavelength='410', pair=0)\r\n\r\nbefore_disk_ts = data.time.sel(**selector).values[()]\r\n\r\ndata.time.encoding = {'units': 'microseconds since 1900-01-01', 'calendar': 'proleptic_gregorian'}\r\n\r\ndata.to_netcdf(tmp_path)\r\nafter_disk_ts = xr.load_dataarray(tmp_path).time.sel(**selector).values[()]\r\n\r\nprint(f'before roundtrip: {before_disk_ts}')\r\nprint(f' after roundtrip: {after_disk_ts}')\r\n```\r\noutput:\r\n```\r\nbefore roundtrip: 2017-02-22T16:24:10.586000000\r\nafter roundtrip:  2017-02-22T16:24:10.585999872\r\n```\r\n\r\n#### Expected Output\r\n```\r\nBefore: 2017-02-22T16:24:10.586000000\r\nAfter:  2017-02-22T16:24:10.586000000\r\n```\r\n\r\n#### Problem Description\r\n<!-- this should explain why the current behavior is a problem and why the expected output is a better solution -->\r\n\r\nAs you can see, I lose millisecond precision in this data. (The same happens when I use millisecond in the encoding).\r\n\r\n#### Versions\r\n\r\n<details><summary>Output of <tt>xr.show_versions()</tt></summary>\r\n\r\n<!-- Paste the output here xr.show_versions() here -->\r\nINSTALLED VERSIONS\r\n------------------\r\ncommit: None\r\npython: 3.7.6 | packaged by conda-forge | (default, Jan  7 2020, 22:05:27) \r\n[Clang 9.0.1 ]\r\npython-bits: 64\r\nOS: Darwin\r\nOS-release: 19.4.0\r\nmachine: x86_64\r\nprocessor: i386\r\nbyteorder: little\r\nLC_ALL: None\r\nLANG: en_US.UTF-8\r\nLOCALE: None.UTF-8\r\nlibhdf5: 1.10.5\r\nlibnetcdf: 4.7.3\r\n\r\nxarray: 0.15.1\r\npandas: 1.0.1\r\nnumpy: 1.18.1\r\nscipy: 1.4.1\r\nnetCDF4: 1.5.3\r\npydap: None\r\nh5netcdf: 0.8.0\r\nh5py: 2.10.0\r\nNio: None\r\nzarr: None\r\ncftime: 1.0.4.2\r\nnc_time_axis: None\r\nPseudoNetCDF: None\r\nrasterio: None\r\ncfgrib: None\r\niris: None\r\nbottleneck: None\r\ndask: 2.11.0\r\ndistributed: 2.14.0\r\nmatplotlib: 3.1.3\r\ncartopy: None\r\nseaborn: 0.10.0\r\nnumbagg: None\r\nsetuptools: 45.2.0.post20200209\r\npip: 20.0.2\r\nconda: None\r\npytest: 5.3.5\r\nIPython: 7.12.0\r\nsphinx: 2.4.3\r\n\r\n</details>\r\n\n",
  "hints_text": "This has something to do with the time values at some point being a float:\r\n\r\n```python\r\n>>> import numpy as np\r\n>>> np.datetime64(\"2017-02-22T16:24:10.586000000\").astype(\"float64\").astype(np.dtype('<M8[ns]'))\r\nnumpy.datetime64('2017-02-22T16:24:10.585999872')\r\n```\r\n\r\nIt looks like this is happening somewhere in the [cftime](https://github.com/Unidata/cftime/blob/master/cftime/_cftime.pyx#L870) library.\nThanks for the report @half-adder.\r\n\r\nThis indeed is related to times being encoded as floats, but actually is not cftime-related (the times here not being encoded using cftime; we only use cftime for non-standard calendars and out of nanosecond-resolution bounds dates).  \r\n\r\nHere's a minimal working example that illustrates the issue with the current logic in [`coding.times.encode_cf_datetime`](https://github.com/pydata/xarray/blob/69548df9826cde9df6cbdae9c033c9fb1e62d493/xarray/coding/times.py#L343-L389):\r\n```\r\nIn [1]: import numpy as np; import pandas as pd\r\n\r\nIn [2]: times = pd.DatetimeIndex([np.datetime64(\"2017-02-22T16:27:08.732000000\")])\r\n\r\nIn [3]: reference = pd.Timestamp(\"1900-01-01\")\r\n\r\nIn [4]: units = np.timedelta64(1, \"us\")\r\n\r\nIn [5]: (times - reference).values[0]\r\nOut[5]: numpy.timedelta64(3696769628732000000,'ns')\r\n\r\nIn [6]: ((times - reference) / units).values[0]\r\nOut[6]: 3696769628732000.5\r\n```\r\nIn principle, we should be able to represent the difference between this date and the reference date in an integer amount of microseconds, but timedelta division produces a float.  We currently [try to cast these floats to integers when possible](https://github.com/pydata/xarray/blob/69548df9826cde9df6cbdae9c033c9fb1e62d493/xarray/coding/times.py#L388), but that's not always safe to do, e.g. in the case above.\r\n\r\nIt would be great to make roundtripping times -- particularly standard calendar datetimes like these -- more robust.  It's possible we could now leverage [floor division (i.e. `//`) of timedeltas within NumPy](https://github.com/numpy/numpy/pull/12308) for this (assuming we first check that the unit conversion divisor exactly divides each timedelta; if it doesn't we'd fall back to using floats):\r\n\r\n```\r\nIn [7]: ((times - reference) // units).values[0]\r\nOut[7]: 3696769628732000\r\n```\r\nThese precision issues can be tricky, however, so we'd need to think things through carefully.  Even if we fixed this on the encoding side, [things are converted to floats during decoding](https://github.com/pydata/xarray/blob/69548df9826cde9df6cbdae9c033c9fb1e62d493/xarray/coding/times.py#L125-L132), so we'd need to make a change there too.\nJust stumbled upon this as well. Internally, `datetime64[ns]` is simply an 8-byte int. Why on earth would it be serialized in a lossy way as a float64?...\r\n\r\nSimply telling it to `encoding={...: {'dtype': 'int64'}}` won't work since then it complains about serializing float as an int.\r\n\r\nIs there a way out of this, other than not using `M8[ns]` dtypes at all with xarray?\r\n\r\nThis is a huge issue, as anyone using nanosecond-precision timestamps with xarray would unknowingly and silently read wrong data after deserializing.\n> Internally, datetime64[ns] is simply an 8-byte int. Why on earth would it be serialized in a lossy way as a float64?...\r\n\r\nThe short answer is that [CF conventions allow for dates to be encoded with floating point values](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#time-coordinate), so we encounter that in data that xarray ingests from other sources (i.e. files that were not even produced with Python, let alone xarray).  If we didn't have to worry about roundtripping files that followed those conventions, I agree we would just encode everything with nanosecond units as `int64` values.  \r\n\r\n> This is a huge issue, as anyone using nanosecond-precision timestamps with xarray would unknowingly and silently read wrong data after deserializing.\r\n\r\nYes, I can see why this would be quite frustrating.  In principle we should be able to handle this (contributions are welcome); it just has not been a priority up to this point.  In my experience xarray's current encoding and decoding methods for standard calendar times work well up to at least second precision.\nCan we use the `encoding[\"dtype\"]` field to solve this? i.e. use `int64` when `encoding[\"dtype\"]` is not set and use the specified value when available?\n> In principle we should be able to handle this (contributions are welcome)\r\n\r\nI don't mind contributing but not knowing the netcdf stuff inside out I'm not sure I have a good vision on what's the proper way to do it. My use case is very simple - I have an in-memory xr.Dataset that I want to save() and then load() without losses.\r\n\r\nShould it just be an `xr.save(..., m8=True)` (or whatever that flag would be called), so that all of numpy's `M8[...]` and `m8[...]` would be serialized transparently (as int64, that is) without passing them through the whole cftime pipeline. It would be then nice, of course, if `xr.load` was also aware of this convention (via some special attribute or somehow else) and could convert them back like `.view('M8[ns]')` when loading. I think xarray should also throw an exception if it detects timestamps/timedeltas of nanosecond precision that it can't serialize without going through int-float-int routine (or automatically revert to using this transparent but netcdf-incompatible mode).\r\n\r\nMaybe this is not the proper way to do it - ideas welcome (there's also an open PR - #4400 - mind checking that out?)\n> Can we use the encoding[\"dtype\"] field to solve this? i.e. use int64 when encoding[\"dtype\"] is not set and use the specified value when available?\r\n\r\nI think a lot of logic needs to be reshuffled, because as of right now it will complain \"you can't store a float64 in int64\" or something along those lines, when trying to do it with a nanosecond timestamp.\nI would look here: https://github.com/pydata/xarray/blob/255bc8ee9cbe8b212e3262b0d4b2e32088a08064/xarray/coding/times.py#L440-L474",
  "created_at": "2020-12-12T21:43:57Z",
  "version": "0.12",
  "FAIL_TO_PASS": "[\"xarray/tests/test_coding_times.py::test_cf_timedelta[1ns-nanoseconds-numbers5]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[D-nanoseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[H-nanoseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[L-nanoseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[N-nanoseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[S-nanoseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[T-nanoseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[U-nanoseconds]\", \"xarray/tests/test_coding_times.py::test_encode_decode_roundtrip[L]\", \"xarray/tests/test_coding_times.py::test_encode_decode_roundtrip[N]\", \"xarray/tests/test_coding_times.py::test_encode_decode_roundtrip[S]\", \"xarray/tests/test_coding_times.py::test_encode_decode_roundtrip[U]\", \"xarray/tests/test_coding_times.py::test_infer_datetime_units[L-milliseconds]\", \"xarray/tests/test_coding_times.py::test_infer_datetime_units[N-nanoseconds]\", \"xarray/tests/test_coding_times.py::test_infer_datetime_units[U-microseconds]\"]",
  "PASS_TO_PASS": "[\"xarray/tests/test_coding_times.py::test_cf_timedelta[1D-days-numbers0]\", \"xarray/tests/test_coding_times.py::test_cf_timedelta[1h-hours-numbers2]\", \"xarray/tests/test_coding_times.py::test_cf_timedelta[1ms-milliseconds-numbers3]\", \"xarray/tests/test_coding_times.py::test_cf_timedelta[1us-microseconds-numbers4]\", \"xarray/tests/test_coding_times.py::test_cf_timedelta[NaT-days-nan]\", \"xarray/tests/test_coding_times.py::test_cf_timedelta[timedeltas1-days-numbers1]\", \"xarray/tests/test_coding_times.py::test_cf_timedelta[timedeltas6-None-numbers6]\", \"xarray/tests/test_coding_times.py::test_cf_timedelta[timedeltas7-hours-numbers7]\", \"xarray/tests/test_coding_times.py::test_cf_timedelta[timedeltas9-days-numbers9]\", \"xarray/tests/test_coding_times.py::test_cf_timedelta_2d\", \"xarray/tests/test_coding_times.py::test_contains_cftime_datetimes_non_cftimes[non_cftime_data0]\", \"xarray/tests/test_coding_times.py::test_contains_cftime_datetimes_non_cftimes[non_cftime_data1]\", \"xarray/tests/test_coding_times.py::test_decode_cf[360_day]\", \"xarray/tests/test_coding_times.py::test_decode_cf[365_day]\", \"xarray/tests/test_coding_times.py::test_decode_cf[366_day]\", \"xarray/tests/test_coding_times.py::test_decode_cf[all_leap]\", \"xarray/tests/test_coding_times.py::test_decode_cf[gregorian]\", \"xarray/tests/test_coding_times.py::test_decode_cf[julian]\", \"xarray/tests/test_coding_times.py::test_decode_cf[noleap]\", \"xarray/tests/test_coding_times.py::test_decode_cf[proleptic_gregorian]\", \"xarray/tests/test_coding_times.py::test_decode_cf[standard]\", \"xarray/tests/test_coding_times.py::test_decode_cf_datetime_non_standard_units\", \"xarray/tests/test_coding_times.py::test_decode_cf_time_bounds\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[D-days]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[D-hours]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[D-microseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[D-milliseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[D-minutes]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[D-seconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[H-days]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[H-hours]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[H-microseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[H-milliseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[H-minutes]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[H-seconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[L-days]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[L-hours]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[L-microseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[L-milliseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[L-minutes]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[L-seconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[N-days]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[N-hours]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[N-microseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[N-milliseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[N-minutes]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[N-seconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[S-days]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[S-hours]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[S-microseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[S-milliseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[S-minutes]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[S-seconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[T-days]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[T-hours]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[T-microseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[T-milliseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[T-minutes]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[T-seconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[U-days]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[U-hours]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[U-microseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[U-milliseconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[U-minutes]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_defaults_to_correct_dtype[U-seconds]\", \"xarray/tests/test_coding_times.py::test_encode_cf_datetime_pandas_min\", \"xarray/tests/test_coding_times.py::test_encode_decode_roundtrip[D]\", \"xarray/tests/test_coding_times.py::test_encode_decode_roundtrip[H]\", \"xarray/tests/test_coding_times.py::test_encode_decode_roundtrip[T]\", \"xarray/tests/test_coding_times.py::test_infer_datetime_units[D-days]\", \"xarray/tests/test_coding_times.py::test_infer_datetime_units[H-hours]\", \"xarray/tests/test_coding_times.py::test_infer_datetime_units[S-seconds]\", \"xarray/tests/test_coding_times.py::test_infer_datetime_units[T-minutes]\", \"xarray/tests/test_coding_times.py::test_infer_datetime_units_with_NaT[dates0-days\", \"xarray/tests/test_coding_times.py::test_infer_datetime_units_with_NaT[dates1-days\", \"xarray/tests/test_coding_times.py::test_infer_datetime_units_with_NaT[dates2-days\", \"xarray/tests/test_coding_times.py::test_infer_timedelta_units[deltas0-days]\", \"xarray/tests/test_coding_times.py::test_infer_timedelta_units[deltas1-hours]\", \"xarray/tests/test_coding_times.py::test_infer_timedelta_units[deltas2-minutes]\", \"xarray/tests/test_coding_times.py::test_infer_timedelta_units[deltas3-seconds]\", \"xarray/tests/test_coding_times.py::test_use_cftime_default_standard_calendar_in_range[gregorian]\", \"xarray/tests/test_coding_times.py::test_use_cftime_default_standard_calendar_in_range[proleptic_gregorian]\", \"xarray/tests/test_coding_times.py::test_use_cftime_default_standard_calendar_in_range[standard]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_non_standard_calendar[1500-360_day]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_non_standard_calendar[1500-365_day]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_non_standard_calendar[1500-366_day]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_non_standard_calendar[1500-all_leap]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_non_standard_calendar[1500-julian]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_non_standard_calendar[1500-noleap]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_non_standard_calendar[2000-360_day]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_non_standard_calendar[2000-365_day]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_non_standard_calendar[2000-366_day]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_non_standard_calendar[2000-all_leap]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_non_standard_calendar[2000-julian]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_non_standard_calendar[2000-noleap]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_non_standard_calendar[2500-360_day]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_non_standard_calendar[2500-365_day]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_non_standard_calendar[2500-366_day]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_non_standard_calendar[2500-all_leap]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_non_standard_calendar[2500-julian]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_non_standard_calendar[2500-noleap]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_standard_calendar_in_range[gregorian]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_standard_calendar_in_range[proleptic_gregorian]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_standard_calendar_in_range[standard]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_standard_calendar_out_of_range[1500-gregorian]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_standard_calendar_out_of_range[1500-proleptic_gregorian]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_standard_calendar_out_of_range[1500-standard]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_standard_calendar_out_of_range[2500-gregorian]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_standard_calendar_out_of_range[2500-proleptic_gregorian]\", \"xarray/tests/test_coding_times.py::test_use_cftime_false_standard_calendar_out_of_range[2500-standard]\"]",
  "environment_setup_commit": "1c198a191127c601d091213c4b3292a8bb3054e1",
  "patch_files": [
    "xarray/coding/times.py"
  ],
  "test_patch_files": [
    "xarray/tests/test_coding_times.py"
  ],
  "patch_diff_details": {
    "xarray/coding/times.py": {
      "diffs": [
        {
          "start_line_old": 29,
          "end_line_old": 29,
          "file_pos": 5,
          "file_context_length": 74163,
          "pos": 5,
          "context_length": 3073
        },
        {
          "start_line_old": 38,
          "end_line_old": 38,
          "file_pos": 5,
          "file_context_length": 74163,
          "pos": 5,
          "context_length": 3073
        },
        {
          "start_line_old": 47,
          "end_line_old": 47,
          "file_pos": 5,
          "file_context_length": 74163,
          "pos": 5,
          "context_length": 3073
        },
        {
          "start_line_old": 154,
          "end_line_old": 167,
          "file_pos": 5,
          "file_context_length": 74163,
          "closest_snippet_id": "/tmp/repos/xarray/xarray/coding/times.py__cleanup_netcdf_time_units_cast_to_int_if_safe.3.1",
          "closest_snippet_line_distance": 191
        },
        {
          "start_line_old": 255,
          "end_line_old": 259,
          "file_pos": 5,
          "file_context_length": 74163,
          "closest_snippet_id": "/tmp/repos/xarray/xarray/coding/times.py__decode_cf_datetime_dtype__decode_datetime_with_cftime.2.1",
          "closest_snippet_line_distance": 124,
          "pos": 21,
          "context_length": 8903
        },
        {
          "start_line_old": 419,
          "end_line_old": 419,
          "file_pos": 5,
          "file_context_length": 74163,
          "closest_snippet_id": "/tmp/repos/xarray/xarray/coding/times.py__cleanup_netcdf_time_units_cast_to_int_if_safe.3.1",
          "closest_snippet_line_distance": 42
        }
      ]
    }
  },
  "vectors": 1037,
  "snippets": [
    {
      "position": 1,
      "id": "/tmp/repos/xarray/xarray/core/dataset.py_copy__DATETIMEINDEX_COMPONENTS.1",
      "distance": 0.8928103446960449,
      "file_path": "xarray/core/dataset.py",
      "start_line": 1,
      "end_line": 135,
      "tokens": 643,
      "context_length": 643
    },
    {
      "position": 2,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/dataset_io.py_os_IOSingleNetCDF.make_ds.self.ds.self.vinds.1",
      "distance": 0.8943989872932434,
      "file_path": "asv_bench/benchmarks/dataset_io.py",
      "start_line": 1,
      "end_line": 93,
      "tokens": 715,
      "context_length": 1358
    },
    {
      "position": 3,
      "id": "/tmp/repos/xarray/xarray/coding/cftime_offsets.py__FREQUENCIES__FREQUENCIES.1",
      "distance": 0.9073712229728699,
      "file_path": "xarray/coding/cftime_offsets.py",
      "start_line": 579,
      "end_line": 641,
      "tokens": 832,
      "context_length": 2190
    },
    {
      "position": 4,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/dataarray_missing.py_pd_",
      "distance": 0.9104170799255371,
      "file_path": "asv_bench/benchmarks/dataarray_missing.py",
      "start_line": 1,
      "end_line": 75,
      "tokens": 531,
      "context_length": 2721
    },
    {
      "position": 5,
      "id": "/tmp/repos/xarray/xarray/coding/times.py_re__netcdf_to_numpy_timeunit.3.1",
      "distance": 0.9308562278747559,
      "file_path": "xarray/coding/times.py",
      "start_line": 1,
      "end_line": 53,
      "tokens": 352,
      "context_length": 3073,
      "file_pos": 5
    },
    {
      "position": 6,
      "id": "/tmp/repos/xarray/xarray/__init__.py_pkg_resources_",
      "distance": 0.9318340420722961,
      "file_path": "xarray/__init__.py",
      "start_line": 1,
      "end_line": 93,
      "tokens": 603,
      "context_length": 3676
    },
    {
      "position": 7,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/reindexing.py_np_",
      "distance": 0.9419715404510498,
      "file_path": "asv_bench/benchmarks/reindexing.py",
      "start_line": 1,
      "end_line": 49,
      "tokens": 413,
      "context_length": 4089
    },
    {
      "position": 8,
      "id": "/tmp/repos/xarray/xarray/core/dataarray.py_datetime_23.4.2.iris_Cube.1",
      "distance": 0.9504679441452026,
      "file_path": "xarray/core/dataarray.py",
      "start_line": 1,
      "end_line": 82,
      "tokens": 436,
      "context_length": 4525
    },
    {
      "position": 9,
      "id": "/tmp/repos/xarray/xarray/plot/utils.py_itertools__determine_extend.4.1",
      "distance": 0.9553337693214417,
      "file_path": "xarray/plot/utils.py",
      "start_line": 1,
      "end_line": 54,
      "tokens": 283,
      "context_length": 4808
    },
    {
      "position": 10,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/indexing.py_os_vectorized_assignment_values.1",
      "distance": 0.9640065431594849,
      "file_path": "asv_bench/benchmarks/indexing.py",
      "start_line": 1,
      "end_line": 59,
      "tokens": 733,
      "context_length": 5541
    },
    {
      "position": 11,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/dataset_io.py_IOReadMultipleNetCDF4Dask_IOReadMultipleNetCDF4Dask.time_open_dataset_netcdf4_with_time_chunks_multiprocessing.1.1",
      "distance": 0.9744884967803955,
      "file_path": "asv_bench/benchmarks/dataset_io.py",
      "start_line": 347,
      "end_line": 398,
      "tokens": 442,
      "context_length": 5983
    },
    {
      "position": 12,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/interp.py_np_new_y_long.1",
      "distance": 0.9781786203384399,
      "file_path": "asv_bench/benchmarks/interp.py",
      "start_line": 1,
      "end_line": 22,
      "tokens": 184,
      "context_length": 6167
    },
    {
      "position": 13,
      "id": "/tmp/repos/xarray/xarray/core/missing.py_dt_broadcast_variables",
      "distance": 0.983542263507843,
      "file_path": "xarray/core/missing.py",
      "start_line": 1,
      "end_line": 18,
      "tokens": 133,
      "context_length": 6300
    },
    {
      "position": 14,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/dataset_io.py_IOReadMultipleNetCDF3Dask_IOReadMultipleNetCDF3Dask.time_open_dataset_scipy_with_time_chunks.1.1",
      "distance": 0.9846696853637695,
      "file_path": "asv_bench/benchmarks/dataset_io.py",
      "start_line": 401,
      "end_line": 432,
      "tokens": 264,
      "context_length": 6564
    },
    {
      "position": 15,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/dataset_io.py_IOReadSingleNetCDF4Dask_IOReadSingleNetCDF4Dask.time_load_dataset_netcdf4_with_time_chunks_multiprocessing.1.1",
      "distance": 0.9907773733139038,
      "file_path": "asv_bench/benchmarks/dataset_io.py",
      "start_line": 150,
      "end_line": 187,
      "tokens": 349,
      "context_length": 6913
    },
    {
      "position": 16,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/dataset_io.py_IOWriteSingleNetCDF3_IOReadSingleNetCDF4.time_vectorized_indexing.ds_2.1",
      "distance": 0.9928758144378662,
      "file_path": "asv_bench/benchmarks/dataset_io.py",
      "start_line": 96,
      "end_line": 126,
      "tokens": 269,
      "context_length": 7182
    },
    {
      "position": 17,
      "id": "/tmp/repos/xarray/xarray/coding/times.py__decode_cf_datetime_dtype__decode_datetime_with_cftime.2.1",
      "distance": 1.0020476579666138,
      "file_path": "xarray/coding/times.py",
      "start_line": 103,
      "end_line": 135,
      "tokens": 283,
      "context_length": 7465,
      "file_pos": 12
    },
    {
      "position": 18,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/pandas.py_np_",
      "distance": 1.0055190324783325,
      "file_path": "asv_bench/benchmarks/pandas.py",
      "start_line": 1,
      "end_line": 25,
      "tokens": 160,
      "context_length": 7625
    },
    {
      "position": 19,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/dataset_io.py_IOMultipleNetCDF_IOMultipleNetCDF.make_ds.self.ds.11.10",
      "distance": 1.0090231895446777,
      "file_path": "asv_bench/benchmarks/dataset_io.py",
      "start_line": 222,
      "end_line": 296,
      "tokens": 613,
      "context_length": 8238
    },
    {
      "position": 20,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/dataset_io.py_IOReadSingleNetCDF3Dask_IOReadSingleNetCDF3Dask.time_load_dataset_scipy_with_time_chunks.1.1",
      "distance": 1.0097448825836182,
      "file_path": "asv_bench/benchmarks/dataset_io.py",
      "start_line": 190,
      "end_line": 219,
      "tokens": 265,
      "context_length": 8503
    },
    {
      "position": 21,
      "id": "/tmp/repos/xarray/xarray/coding/times.py_to_timedelta_unboxed_infer_calendar_name.2.2.1.1",
      "distance": 1.0104966163635254,
      "file_path": "xarray/coding/times.py",
      "start_line": 226,
      "end_line": 269,
      "tokens": 400,
      "context_length": 8903,
      "file_pos": 13
    },
    {
      "position": 22,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/rolling.py_np_randn_long.1",
      "distance": 1.0153087377548218,
      "file_path": "asv_bench/benchmarks/rolling.py",
      "start_line": 1,
      "end_line": 17,
      "tokens": 117,
      "context_length": 9020
    },
    {
      "position": 23,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/dataset_io.py_IOReadSingleNetCDF3_IOReadSingleNetCDF3.time_vectorized_indexing.ds_2.1",
      "distance": 1.0164607763290405,
      "file_path": "asv_bench/benchmarks/dataset_io.py",
      "start_line": 129,
      "end_line": 147,
      "tokens": 163,
      "context_length": 9183
    },
    {
      "position": 24,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/indexing.py_HugeAxisSmallSliceIndexing_",
      "distance": 1.0166714191436768,
      "file_path": "asv_bench/benchmarks/indexing.py",
      "start_line": 145,
      "end_line": 162,
      "tokens": 145,
      "context_length": 9328
    },
    {
      "position": 25,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/dataset_io.py_create_delayed_write_",
      "distance": 1.0172796249389648,
      "file_path": "asv_bench/benchmarks/dataset_io.py",
      "start_line": 435,
      "end_line": 470,
      "tokens": 186,
      "context_length": 9514
    },
    {
      "position": 26,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/dataset_io.py_IOReadMultipleNetCDF3_IOReadMultipleNetCDF3.time_open_dataset_scipy.1",
      "distance": 1.0179307460784912,
      "file_path": "asv_bench/benchmarks/dataset_io.py",
      "start_line": 331,
      "end_line": 344,
      "tokens": 112,
      "context_length": 9626
    },
    {
      "position": 27,
      "id": "/tmp/repos/xarray/xarray/core/duck_array_ops.py_58__mean.1",
      "distance": 1.0362396240234375,
      "file_path": "xarray/core/duck_array_ops.py",
      "start_line": 353,
      "end_line": 378,
      "tokens": 270,
      "context_length": 9896
    },
    {
      "position": 28,
      "id": "/tmp/repos/xarray/doc/conf.py_1_project_dir.1",
      "distance": 1.0423064231872559,
      "file_path": "doc/conf.py",
      "start_line": 1,
      "end_line": 105,
      "tokens": 751,
      "context_length": 10647
    },
    {
      "position": 29,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/dataset_io.py_IOWriteMultipleNetCDF3_IOWriteMultipleNetCDF3.time_write_dataset_scipy.1",
      "distance": 1.044625997543335,
      "file_path": "asv_bench/benchmarks/dataset_io.py",
      "start_line": 299,
      "end_line": 312,
      "tokens": 113,
      "context_length": 10760
    },
    {
      "position": 30,
      "id": "/tmp/repos/xarray/xarray/core/common.py_DataWithCoords.resample.2_DataWithCoords.resample.18.1",
      "distance": 1.0490987300872803,
      "file_path": "xarray/core/common.py",
      "start_line": 1095,
      "end_line": 1152,
      "tokens": 580,
      "context_length": 11340
    },
    {
      "position": 31,
      "id": "/tmp/repos/xarray/doc/gallery/plot_rasterio.py_1_",
      "distance": 1.0520378351211548,
      "file_path": "doc/gallery/plot_rasterio.py",
      "start_line": 1,
      "end_line": 55,
      "tokens": 402,
      "context_length": 11742
    },
    {
      "position": 32,
      "id": "/tmp/repos/xarray/xarray/core/utils.py_hashable_ensure_us_time_resolution.3.1",
      "distance": 1.0524290800094604,
      "file_path": "xarray/core/utils.py",
      "start_line": 644,
      "end_line": 677,
      "tokens": 233,
      "context_length": 11975
    },
    {
      "position": 33,
      "id": "/tmp/repos/xarray/xarray/core/alignment.py_align.1_align.1",
      "distance": 1.056865930557251,
      "file_path": "xarray/core/alignment.py",
      "start_line": 82,
      "end_line": 271,
      "tokens": 1952,
      "context_length": 13927
    },
    {
      "position": 34,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/dataset_io.py_IOReadMultipleNetCDF4_IOReadMultipleNetCDF4.time_open_dataset_netcdf4.1",
      "distance": 1.057645320892334,
      "file_path": "asv_bench/benchmarks/dataset_io.py",
      "start_line": 315,
      "end_line": 328,
      "tokens": 114,
      "context_length": 14041
    },
    {
      "position": 35,
      "id": "/tmp/repos/xarray/xarray/coding/cftime_offsets.py_Day_Second.__apply__.1.1",
      "distance": 1.0611475706100464,
      "file_path": "xarray/coding/cftime_offsets.py",
      "start_line": 539,
      "end_line": 576,
      "tokens": 184,
      "context_length": 14225
    },
    {
      "position": 36,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/indexing.py_Base_Base.setup.self.ds.1",
      "distance": 1.0629315376281738,
      "file_path": "asv_bench/benchmarks/indexing.py",
      "start_line": 62,
      "end_line": 76,
      "tokens": 151,
      "context_length": 14376
    },
    {
      "position": 37,
      "id": "/tmp/repos/xarray/xarray/core/merge.py_merge.1_merge.1",
      "distance": 1.0652122497558594,
      "file_path": "xarray/core/merge.py",
      "start_line": 635,
      "end_line": 842,
      "tokens": 2740,
      "context_length": 17116
    },
    {
      "position": 38,
      "id": "/tmp/repos/xarray/xarray/core/nputils.py_nanmin_",
      "distance": 1.0654596090316772,
      "file_path": "xarray/core/nputils.py",
      "start_line": 280,
      "end_line": 291,
      "tokens": 155,
      "context_length": 17271
    },
    {
      "position": 39,
      "id": "/tmp/repos/xarray/xarray/coding/times.py__cleanup_netcdf_time_units_cast_to_int_if_safe.3.1",
      "distance": 1.0660243034362793,
      "file_path": "xarray/coding/times.py",
      "start_line": 345,
      "end_line": 377,
      "tokens": 253,
      "context_length": 17524,
      "file_pos": 22
    },
    {
      "position": 40,
      "id": "/tmp/repos/xarray/xarray/core/common.py_DataWithCoords.resample_DataWithCoords.resample.1",
      "distance": 1.0664993524551392,
      "file_path": "xarray/core/common.py",
      "start_line": 985,
      "end_line": 1094,
      "tokens": 1167,
      "context_length": 18691
    },
    {
      "position": 41,
      "id": "/tmp/repos/xarray/xarray/core/common.py_warnings_T.1",
      "distance": 1.0680673122406006,
      "file_path": "xarray/core/common.py",
      "start_line": 1,
      "end_line": 35,
      "tokens": 183,
      "context_length": 18874
    },
    {
      "position": 42,
      "id": "/tmp/repos/xarray/xarray/coding/cftime_offsets.py_normalize_date__generate_linear_range.7.1",
      "distance": 1.068621039390564,
      "file_path": "xarray/coding/cftime_offsets.py",
      "start_line": 695,
      "end_line": 719,
      "tokens": 197,
      "context_length": 19071
    },
    {
      "position": 43,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/unstacking.py_np_",
      "distance": 1.0690741539001465,
      "file_path": "asv_bench/benchmarks/unstacking.py",
      "start_line": 1,
      "end_line": 25,
      "tokens": 159,
      "context_length": 19230
    },
    {
      "position": 44,
      "id": "/tmp/repos/xarray/xarray/core/resample_cftime.py_CFTimeGrouper.first_items_CFTimeGrouper.first_items.11.1",
      "distance": 1.0716220140457153,
      "file_path": "xarray/core/resample_cftime.py",
      "start_line": 80,
      "end_line": 110,
      "tokens": 261,
      "context_length": 19491
    },
    {
      "position": 45,
      "id": "/tmp/repos/xarray/xarray/core/accessor_dt.py_Properties._tslib_round_accessor_Properties.round.2.1",
      "distance": 1.0722718238830566,
      "file_path": "xarray/core/accessor_dt.py",
      "start_line": 197,
      "end_line": 249,
      "tokens": 327,
      "context_length": 19818
    },
    {
      "position": 46,
      "id": "/tmp/repos/xarray/xarray/core/indexing.py_enum_maybe_cast_to_coords_dtype",
      "distance": 1.0727362632751465,
      "file_path": "xarray/core/indexing.py",
      "start_line": 1,
      "end_line": 20,
      "tokens": 115,
      "context_length": 19933
    },
    {
      "position": 47,
      "id": "/tmp/repos/xarray/xarray/core/nputils.py_warnings_nanlast.4.1",
      "distance": 1.0728131532669067,
      "file_path": "xarray/core/nputils.py",
      "start_line": 1,
      "end_line": 33,
      "tokens": 244,
      "context_length": 20177
    },
    {
      "position": 48,
      "id": "/tmp/repos/xarray/xarray/core/accessor_dt.py_DatetimeAccessor.year_DatetimeAccessor.nanosecond.1",
      "distance": 1.0756675004959106,
      "file_path": "xarray/core/accessor_dt.py",
      "start_line": 349,
      "end_line": 370,
      "tokens": 230,
      "context_length": 20407
    },
    {
      "position": 49,
      "id": "/tmp/repos/xarray/xarray/convert.py_1__filter_attrs.2.1",
      "distance": 1.0773370265960693,
      "file_path": "xarray/convert.py",
      "start_line": 1,
      "end_line": 60,
      "tokens": 330,
      "context_length": 20737
    },
    {
      "position": 50,
      "id": "/tmp/repos/xarray/xarray/coding/cftimeindex.py_CFTimeIndex.__add___CFTimeIndex.__rsub__.1.2.1",
      "distance": 1.081239104270935,
      "file_path": "xarray/coding/cftimeindex.py",
      "start_line": 547,
      "end_line": 580,
      "tokens": 284,
      "context_length": 21021
    }
  ],
  "files": [
    {
      "file_path": "xarray/core/dataset.py",
      "position": 1,
      "tokens": 57434,
      "context_length": 57434
    },
    {
      "file_path": "asv_bench/benchmarks/dataset_io.py",
      "position": 2,
      "tokens": 3605,
      "context_length": 61039
    },
    {
      "file_path": "xarray/coding/cftime_offsets.py",
      "position": 3,
      "tokens": 8317,
      "context_length": 69356
    },
    {
      "file_path": "asv_bench/benchmarks/dataarray_missing.py",
      "position": 4,
      "tokens": 531,
      "context_length": 69887
    },
    {
      "file_path": "xarray/coding/times.py",
      "position": 5,
      "tokens": 4276,
      "context_length": 74163
    },
    {
      "file_path": "xarray/__init__.py",
      "position": 6,
      "tokens": 603,
      "context_length": 74766
    },
    {
      "file_path": "asv_bench/benchmarks/reindexing.py",
      "position": 7,
      "tokens": 413,
      "context_length": 75179
    },
    {
      "file_path": "xarray/core/dataarray.py",
      "position": 8,
      "tokens": 36365,
      "context_length": 111544
    },
    {
      "file_path": "xarray/plot/utils.py",
      "position": 9,
      "tokens": 6628,
      "context_length": 118172
    },
    {
      "file_path": "asv_bench/benchmarks/indexing.py",
      "position": 10,
      "tokens": 1560,
      "context_length": 119732
    },
    {
      "file_path": "asv_bench/benchmarks/interp.py",
      "position": 11,
      "tokens": 485,
      "context_length": 120217
    },
    {
      "file_path": "xarray/core/missing.py",
      "position": 12,
      "tokens": 6033,
      "context_length": 126250
    },
    {
      "file_path": "asv_bench/benchmarks/pandas.py",
      "position": 13,
      "tokens": 160,
      "context_length": 126410
    },
    {
      "file_path": "asv_bench/benchmarks/rolling.py",
      "position": 14,
      "tokens": 629,
      "context_length": 127039
    },
    {
      "file_path": "xarray/core/duck_array_ops.py",
      "position": 15,
      "tokens": 5232,
      "context_length": 132271
    },
    {
      "file_path": "doc/conf.py",
      "position": 16,
      "tokens": 3549,
      "context_length": 135820
    },
    {
      "file_path": "xarray/core/common.py",
      "position": 17,
      "tokens": 15346,
      "context_length": 151166
    },
    {
      "file_path": "doc/gallery/plot_rasterio.py",
      "position": 18,
      "tokens": 402,
      "context_length": 151568
    },
    {
      "file_path": "xarray/core/utils.py",
      "position": 19,
      "tokens": 5631,
      "context_length": 157199
    },
    {
      "file_path": "xarray/core/alignment.py",
      "position": 20,
      "tokens": 6008,
      "context_length": 163207
    },
    {
      "file_path": "xarray/core/merge.py",
      "position": 21,
      "tokens": 7867,
      "context_length": 171074
    },
    {
      "file_path": "xarray/core/nputils.py",
      "position": 22,
      "tokens": 2470,
      "context_length": 173544
    },
    {
      "file_path": "asv_bench/benchmarks/unstacking.py",
      "position": 23,
      "tokens": 159,
      "context_length": 173703
    },
    {
      "file_path": "xarray/core/resample_cftime.py",
      "position": 24,
      "tokens": 3314,
      "context_length": 177017
    },
    {
      "file_path": "xarray/core/accessor_dt.py",
      "position": 25,
      "tokens": 4607,
      "context_length": 181624
    },
    {
      "file_path": "xarray/core/indexing.py",
      "position": 26,
      "tokens": 11921,
      "context_length": 193545
    },
    {
      "file_path": "xarray/convert.py",
      "position": 27,
      "tokens": 2336,
      "context_length": 195881
    },
    {
      "file_path": "xarray/coding/cftimeindex.py",
      "position": 28,
      "tokens": 6867,
      "context_length": 202748
    }
  ]
}